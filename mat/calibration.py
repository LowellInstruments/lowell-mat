# GPLv3 License
# Copyright (c) 2018 Lowell Instruments, LLC, some rights reserved

"""
Read/write calibration data from a logger or file

Calibration data is found in .lid and .lis files immediately proceeding
the header. The calibration data is found within the HSS and HSE tags. Each
calibration value is on a separate line.

There have been three different versions of calibration coefficients since
the introduction of the MAT logger. This module is responsible for managing
how the various versions are read and written.

V1 Calibration isn't found "in the wild" so it will be ignored

V2 Calibration is stored in the data file in the following way:
3 letter tag, 1 hex number for length, ascii numeric value
eg. AXX61.1201 -- AXX is the tag, 6 is the data length, 1.1201 is the value

V3 Calibration is stored in the data file in the following way:
3 letter tag, 5 byte ascii-85 encoded single precision float
eg. AXX^3r#p -- AXX is the tag, and "^3r#p" is -0.247291 encoded in ascii85
The format is
"""

from abc import ABC, abstractclassmethod, abstractmethod
from mat import ascii85


EMPTY_CHAR = bytes([255]).decode('IBM437')


def make_from_calibration_file(file_path):
    """
    Create a calibration object based on a calibration file generated by the
    Lowell Instruments calibration software.
    """
    with open(file_path, 'r') as fid:
        coefficients = {}
        for line in fid:
            line = line.strip()
            line = _remove_comments(line)
            if not line:
                continue
            tag, value = _split_tag_value(line)
            coefficients[tag] = value

    if 'RVN' not in coefficients.keys():
        coefficients['RVN'] = '2'
    class_ = {'2': V2Calibration, '3': V3Calibration}.get(coefficients['RVN'])
    return class_(coefficients)


def _remove_comments(line):
    if line.startswith('//'):
        return ''
    inline_comment_ind = line.find('//', 9)
    if inline_comment_ind > 0:
        return line[:inline_comment_ind].strip()
    return line


def _split_tag_value(line):
    tag_value = line.split(' ')
    if len(tag_value) != 2:
        raise ValueError('Structure error in host storage file.')
    return tag_value[0], tag_value[1]


def make_from_string(calibration_string):
    """
    Factory function to return correct calibration subclass based on a string
    """
    if _check_if_empty(calibration_string):
        return V2Calibration({})
    _validate_string(calibration_string)
    if calibration_string.startswith('HSSRVN13'):
        return V3Calibration.load_from_string(calibration_string)
    else:
        return V2Calibration.load_from_string(calibration_string)


def _check_if_empty(calibration_string):
    if all([char == EMPTY_CHAR for char in calibration_string]):
        return True
    return False


def _validate_string(calibration_string):
    if not calibration_string.startswith('HSS'):
        raise ValueError('Host storage string must begin with HSS')
    if calibration_string.find('HSE') == -1:
        raise ValueError('Host storage string must contain HSE tag')


def make_from_datafile(file_obj):
    """
    Create a calibration object from a data file (.lid/.lis)
    file_obj is an open .lid/.lis file in binary mode
    """
    _check_binary_mode(file_obj)
    saved_file_pos = file_obj.tell()
    file_obj.seek(0)
    full_header = file_obj.read(1000).decode('IBM437')
    file_obj.seek(saved_file_pos)
    calibration_string = _extract_calibration_string(full_header)
    return make_from_string(calibration_string)


def _check_binary_mode(file_obj):
    if file_obj.mode != 'rb':
        raise ValueError('File is not open for binary reading')


def _extract_calibration_string(full_header):
    calibration_start = full_header.find('HDE\r\n')
    if calibration_start == -1:
        raise ValueError('HDE tag missing from header')
    return full_header[calibration_start+5:calibration_start+385]


def _trim_start(string, n_chars_to_trim):
    return string[n_chars_to_trim:]


class Calibration(ABC):
    def __init__(self, coefficients):
        """
        coefficients is passed to the subclasses with values as strings
        The subclasses must convert the string values to numeric values and
        pass them back to this __init__ method
        The V2 __init__ needs to convert plain text ascii to float
        The V3 __init__ needs to convert five ascii85 characters to float
        """
        if not coefficients:
            coefficients = self.load_generic()
            self.is_generic = True
        else:
            self.is_generic = False

        for tag in coefficients:
            coefficients[tag] = float(coefficients[tag])
        self.coefficients = coefficients

    @abstractclassmethod
    def load_from_string(self, calibration_string):
        pass  # pragma: no cover

    @abstractmethod
    def make_serial_string(self):
        pass  # pragma: no cover

    def load_generic(self):
        coefficients = {'AXX': 1, 'AXY': 0, 'AXZ': 0, 'AXC': 0, 'AXV': 0,
                        'AYX': 0, 'AYY': 1, 'AYZ': 0, 'AYC': 0, 'AYV': 0,
                        'AZX': 0, 'AZY': 0, 'AZZ': 1, 'AZC': 0, 'AZV': 0,
                        'RVN': 2,
                        'TMO': 0,
                        'TMR': 10000,
                        'TMA': 0.0011238100354,
                        'TMB': 0.0002349457073,
                        'TMC': 0.0000000848361,
                        'MXX': 1, 'MXY': 0, 'MXZ': 0, 'MXV': 0,
                        'MYX': 0, 'MYY': 1, 'MYZ': 0, 'MYV': 0,
                        'MZX': 0, 'MZY': 0, 'MZZ': 1, 'MZV': 0,
                        'PRA': 3,
                        'PRB': 0.0016,
                        'PHA': 0,
                        'PHB': 0}
        return coefficients


class V2Calibration(Calibration):
    @classmethod
    def load_from_string(cls, calibration_string):
        coefficients = {}
        for tag, value in cls._generate_tag_value_pairs(calibration_string):
            coefficients[tag] = value
        return cls(coefficients)

    @staticmethod
    def _generate_tag_value_pairs(calibration_string):
        tag = None
        calibration_string = _trim_start(calibration_string, 3)
        while True:
            tag = calibration_string[0:3]
            if tag == 'HSE':
                break
            length = int(calibration_string[3], 16)
            value = calibration_string[4:4+length]
            calibration_string = _trim_start(calibration_string, 4+length)
            yield tag, value

    def make_serial_string(self):
        """
        This generator function formats the host storage dict for writing
        to the logger.
        """
        yield 'RVN12'  # Prior to V3, RVN didn't need to be first, but what the heck...
        for key in self.coefficients:
            if key == 'RVN':
                continue
            # TODO this may need to be changed to a number of decimal points. e.g. %0.3f
            value = str(self.coefficients[key])
            length_hex = '%x' % len(value)
            yield key + length_hex + value


class V3Calibration(Calibration):
    def __init__(self, coefficients):
        for tag in coefficients:
            if 'RVN' in tag:
                coefficients[tag] = float(coefficients[tag])
                continue
            coefficients[tag] = ascii85.ascii85_to_num(coefficients[tag])
        super().__init__(coefficients)

    @classmethod
    def load_from_string(cls, calibration_string):
        coefficients = {'RVN': 3}
        calibration_string = calibration_string[8:]
        tag = calibration_string[:3]
        while tag != 'HSE':
            value = calibration_string[3:8]
            coefficients[tag] = value
            calibration_string = calibration_string[8:]
            tag = calibration_string[0:3]
        return cls(coefficients)

    def make_serial_string(self):
        """
        This generator function formats the host storage dict for writing to the logger.
        """
        yield 'RVN13'
        for key in self.coefficients:
            if key == 'RVN':
                continue
            value = ascii85.num_to_ascii85(self.coefficients[key])
            yield key + value

