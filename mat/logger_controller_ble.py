import bluepy.btle as btle
import time
import re
import xmodem
from mat.logger_controller import LoggerController
from mat.logger_controller import DELAY_COMMANDS


class Delegate(btle.DefaultDelegate):
    def __init__(self):
        btle.DefaultDelegate.__init__(self)
        self.buffer = ''
        self.read_buffer = []
        self.xmodem_buffer = bytes()
        self.xmodem_mode = False
        self.rx_observers = []
        self.sentC = False

    def handleNotification(self, handler, data):
        if not self.xmodem_mode:
            self.buffer += data.decode('utf-8')
            self.buffer = self.buffer.replace(chr(10), '')
            while chr(13) in self.buffer:
                if self.buffer.startswith(chr(13)):
                    self.buffer = self.buffer[1:]
                    continue

                # if a complete string was received, add it to read_buffer
                pos = self.buffer.find(chr(13))
                in_str = self.buffer[:pos]
                self.buffer = self.buffer[pos+1:]
                if in_str:
                    self.read_buffer.append(in_str)

        else:
            if not self.sentC:
                # this receives tag_answer to 'GET' command
                self.buffer += data.decode('utf-8')
            else:
                self.xmodem_buffer += data

    @property
    def in_waiting(self):
        return True if self.read_buffer else False

    def read_line(self):
        # handleNotifications() does read_buffer.append(), pop() is here
        if not self.read_buffer:
            raise IndexError('Read buffer is empty')
        return self.read_buffer.pop(0)


class LoggerControllerBLE(LoggerController):
    def __init__(self, mac):
        super(LoggerController, self).__init__()
        # after ble_connect, 1s delay required at RN4020
        self.peripheral = btle.Peripheral(mac)
        time.sleep(1)
        self.delegate = Delegate()
        self.peripheral.setDelegate(self.delegate)
        uuid_serv = '00035b03-58e6-07dd-021a-08123a000300'
        uuid_char = '00035b03-58e6-07dd-021a-08123a000301'
        self.mldp_service = self.peripheral.getServiceByUUID(uuid_serv)
        self.mldp_data = self.mldp_service.getCharacteristics(uuid_char)[0]
        cccd = self.mldp_data.valHandle + 1
        self.peripheral.writeCharacteristic(cccd, b'\x01\x00')
        self.modem = xmodem.XMODEM(self.getc, self.putc)
        # feel free to change logger level, default is 30
        self.modem.log.setLevel(50)
        self.modem.log.disabled = True
        self.fw_version = ''

    def open(self):
        pass

    def command(self, tag, data=None):
        # build and send the command
        self.delegate.buffer = ''
        self.delegate.read_buffer = []
        data = '' if data is None else data
        length = '%02x' % len(data)
        if tag == 'sleep' or tag == 'RFN':
            self.write(tag + chr(13))
        else:
            self.write(tag + ' ' + length + data + chr(13))

        # expect answer? RST, BSL and sleep commands don't return any
        tag_waiting = tag
        if tag == 'RST' or tag == 'sleep' or tag == 'BSL':
            tag_waiting = ''

        # collect line generated by handleNotification(), if any
        while tag_waiting:
            if not self.peripheral.waitForNotifications(5):
                raise LCBLEException('\tAnswer timeout at ' + tag_waiting)

            if self.delegate.in_waiting:
                inline = self.delegate.read_line()
                if inline.startswith(tag_waiting):
                    # return all the answer and wait if needed
                    if tag in DELAY_COMMANDS:
                        time.sleep(2)
                    return inline
                elif inline.startswith('ERR'):
                    raise LCBLEException('MAT-1W returned ERR')
                elif inline.startswith('INV'):
                    raise LCBLEException('MAT-1W reported invalid command')

    # send commands to RN4020
    def control_command(self, data):
        self.delegate.buffer = ''
        self.delegate.read_buffer = []
        self.write('BTC 00' + data + chr(13))

        # check fw_version to control different behaviors
        if self.fw_version == '':
            raise LCBLEException('Need fw_version() prior control_command().')

        # new firmwares will reach this point
        last_rx = time.time()
        return_val = ''
        while time.time() - last_rx < 3:
            if self.peripheral.waitForNotifications(0.05):
                last_rx = time.time()
            if self.delegate.in_waiting:
                inline = self.delegate.read_line()
                return_val += inline
                # time for RN4020 to clear string, it went ok
                if return_val == 'CMDAOKMLDP':
                    time.sleep(2)
                    return 'CMDAOKMLDP'

        # old firmwares will reach this point
        if self.fw_version < '1.7.28':
            return 'assume_CMDAOKMLDP'
        # check if a new-enough logger could speed up
        if self.fw_version >= '1.7.28' and return_val != 'CMDAOKMLDP':
            raise LCBLEException('RN4020 did not speed up, restarting...')

    # write in BLE characteristic, used in command() and list_/get_files()
    def write(self, data, response=False):
        for c in data:
            self.mldp_data.write(c.encode('utf-8'), withResponse=response)

    def list_files(self):
        # 'DIR' command does not 'answer_tag' like command() does
        files = []
        self.delegate.buffer = ''
        self.delegate.read_buffer = []
        self.write('DIR 00' + chr(13))

        last_rx = time.time()
        while True:
            self.peripheral.waitForNotifications(0.05)
            if self.delegate.in_waiting:
                last_rx = time.time()
                file_str = self.delegate.read_line()
                if file_str == chr(4):
                    break
                # Find all printable characters
                re_obj = re.search('([\x20-\x7E]+)\t+(\d*)', file_str)
                try:
                    file_name = re_obj.group(1)
                    file_size = int(re_obj.group(2))
                except (AttributeError, IndexError):
                    raise LCBLEException('\'DIR\' got invalid filename.')

                files.append((file_name, file_size))
            # timeout while 'DIR', do not return anything
            if time.time() - last_rx > 2:
                raise LCBLEException('\'DIR\' got timeout while listing.')

        return files

    # getc() used by xmodem module
    def getc(self, size, timeout=2):
        time_limit = time.time() + timeout
        while time.time() < time_limit:
            self.peripheral.waitForNotifications(0.05)
            if len(self.delegate.xmodem_buffer) >= size:
                data = self.delegate.xmodem_buffer[:size]
                self.delegate.xmodem_buffer = self.delegate.xmodem_buffer[size:]
                return data
        if len(self.delegate.xmodem_buffer):
            # getc() timed out, but still some data in buffer < size
            data = self.delegate.xmodem_buffer
            self.delegate.xmodem_buffer = bytes()
            return data
        else:
            # getc() timed out with nothing in buffer left
            return None

    def putc(self, data, timeout=1):
        time_limit = time.time() + timeout
        while time.time() < time_limit:
            try:
                # sending the triggering 'C' character for xmodem protocol
                if not self.delegate.sentC:
                    self.mldp_data.write(chr(67).encode('utf-8'),
                                         withResponse=True)
                    self.delegate.sentC = True
                # sending normal binary data
                else:
                    self.mldp_data.write(data, withResponse=True)
            except LCBLEException:
                time.sleep(0.1)
            else:
                return len(data)
        return 0

    def get_file(self, filename, size, out_stream):
        # stage 1 of get_file() command: ascii 'GET' file name
        self.delegate.buffer = ''
        self.delegate.read_buffer = []
        length = '%02x' % len(filename)
        out_str = 'GET ' + length + filename + chr(13)
        self.write(out_str)

        # GET answer 'GET 00', comes bit late! we do as in command()
        last_rx = time.time()
        while True:
            self.peripheral.waitForNotifications(0.05)
            if self.delegate.in_waiting:
                get_ans = self.delegate.read_line()
                if get_ans == 'GET 00':
                    break
            if time.time() - last_rx > 2:
                raise LCBLEException('\'GET\' got timeout while answering.')

        # stage 2 of get_file() command: binary recv() a file
        self.delegate.xmodem_mode = True
        self.delegate.xmodem_buffer = bytes()
        self.delegate.sentC = False
        self.modem.recv(out_stream)
        self.delegate.xmodem_mode = False

        # local filesystem stuff, check if valid size
        out_stream.seek(0, 2)
        if out_stream.tell() < size:
            raise XModemException('Xmodem, error: page < 1024 may be small.')
        out_stream.truncate(size)

    def close(self):
        self.peripheral.disconnect()
        time.sleep(1)
        return 'ok'


class LCBLEException(Exception):
    pass


class XModemException(Exception):
    pass
